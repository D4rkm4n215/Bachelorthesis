\chapter{Fazit} % (fold)
\label{sec:fazit}
Die vorliegende Arbeit hat die Performance von REST- und GraphQL-APIs im Zusammenspiel mit relationalen und graphbasierten Datenbanken untersucht und deren Vor- und Nachteile unter verschiedenen Anfragekomplexitäten analysiert. Dabei wurden die beiden zentralen Forschungsfragen beantwortet:
\newline
\noindent
\textbf{FF-1: Wie unterscheiden sich GraphQL und REST hinsichtlich der Latenzzeit bei unterschiedlichen Anfragenkomplexitäten?}
GraphQL zeigte bei komplexeren Anfragen deutliche Vorteile, da es in der Lage ist, mehrere Datenpunkte in einer einzigen Abfrage zu bündeln, wodurch die Anzahl der API-Aufrufe reduziert wird. Dies führte in Szenarien mit vielen abhängigen Datenpunkten zu geringeren Latenzzeiten im Vergleich zu REST. REST hingegen war bei einfachen Anfragen effizienter, insbesondere aufgrund der nativen Unterstützung von HTTP-Caching, dass sich wiederholende Anfragen deutlich beschleunigt. Jedoch konnte GraphQL diesem Vorteil ausgleichen und lieferte auch bei einfachen Abfragen schnellere Antwortzeiten. Lediglich bei Anfragen, welche eine große Tupelzahl zurücklieferten konnte REST deutlich bessere Antwortzeiten liefern. Die Ergebnisse zeigen, dass die Wahl der API-Technologie stark von der Komplexität der Anfragen abhängt: Währen REST bei Bulk-Abfragen punktet, ist GraphQL bei einfachen und hierarchischen Abfragen überlegen.
\newline
\noindent
\textbf{FF-2: Wie beeinflussen graph- und relationale Datenbanken die Latenz von REST- und GraphQL-APIs?}
Die Wahl der zugrunde liegenden Datenbank hatte ebenfalls einen signifikanten Einfluss auf die Latenz. Relationale Datenbanken erwiesen sich bei der Verarbeitung einfacher und strukturierter Daten als effizient, insbesondere bei Abfragen mit geringen Datenmengen. Mit zunehmender Komplexität und stark vernetzten Daten stießen sie jedoch an ihre Grenzen. Graphdatenbanken, wie Neo4j, zeigten hier ihre Stärke, indem sie Traversal-Mechanismen nutzten, um Beziehungen zwischen Daten effizienter zu verarbeiten. Dies führte bei komplexen Szenarien zu einer spürbaren Reduzierung der Latenz, insbesondere in Kombination mit GraphQL. REST hingegen konnte nicht immer gleichermaßen von graphbasierten Datenbanken profitieren, da zusätzliche Konvertierungsaufwände für die Datenstruktur entstanden
\newline
\noindent
Die vorliegende Arbeit gelangt zu dem Schluss, dass die Kombination aus API-Architektur und Datenbanktechnologie sorgfältig auf die spezifischen Anforderungen eines Anwendungsfalls abgestimmt werden sollte. Während REST und relationale Datenbanken eine bewährte Lösung für klassische Anwendungen darstellen, stellen GraphQL und Graphdatenbanken eine leistungsfähige Alternative für datenintensive und stark vernetzte Anwendungsfälle dar.

% chapter fazit (end)



