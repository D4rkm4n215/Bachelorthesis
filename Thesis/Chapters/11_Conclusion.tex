\chapter{Fazit} % (fold)
\label{sec:fazit}
Die vorliegende Arbeit untersuchte die Performance von REST- und GraphQL-APIs in Kombination mit relationalen sowie graphbasierten Datenbanken und analysierte deren Vor- und Nachteile unter verschiedenen Anfragekomplexitäten, wobei zwei zentrale Forschungsfragen bearbeitet wurden.
\newline
\noindent
\textbf{FF1: Wie unterscheiden sich GraphQL und REST hinsichtlich der Latenzzeit bei unterschiedlichen Anfragenkomplexitäten?}
Bei komplexeren Anfragen zeigt GraphQL deutliche Vorteile, weil es in der Lage ist, mehrere Datenpunkte in einer einzigen Abfrage zu bündeln, was die Anzahl der API-Aufrufe reduziert. Dies führt in Szenarien mit mehreren abhängigen Datenpunkten zu geringeren Latenzzeiten im Vergleich zu REST. Dieses hingegen erweist sich bei einfachen Anfragen als effizienter, insbesondere aufgrund der nativen Unterstützung von HTTP-Caching, das sich wiederholende Anfragen deutlich beschleunigt. Jedoch gleicht GraphQL diesen Vorteil aus und zeigt auch bei einfachen Abfragen schnellere Antwortzeiten. Lediglich bei Anfragen, die eine große Tupelzahl zurückliefern, ergeben sich bei REST deutlich schnellere Antwortzeiten. Gemäß den Ergebnissen hängt die Wahl der API-Technologie stark von der Komplexität der Anfragen ab: Während sich REST für Bulk-Abfragen anbietet, zeigt sich GraphQL bei einfachen und hierarchischen Abfragen überlegen. 
\newline
\noindent
\textbf{FF2: Wie beeinflussen Graph- und relationale Datenbanken die Latenz von REST- und GraphQL-APIs?}
Die Wahl der zugrunde liegenden Datenbank hat ebenfalls einen signifikanten Einfluss auf die Latenz: Relationale Datenbanken erweisen sich bei der Verarbeitung einfacher und strukturierter Daten als effizient, insbesondere bei Abfragen mit geringen Datenmengen. Mit zunehmender Komplexität und stark vernetzten Daten stoßen sie jedoch an ihre Grenzen. Graphdatenbanken wie Neo4j zeigen hier ihre Stärke, indem sie Traversal-Mechanismen nutzen, um Beziehungen zwischen Daten effizienter zu verarbeiten. Dies führt bei komplexen Szenarien zu einer deutlichen Reduzierung der Latenz, insbesondere in Kombination mit GraphQL. Hingegen profitiert REST nur begrenzt von graphbasierten Datenbanken, weil zusätzliche Konvertierungsaufwände für die Datenstruktur entstehen.

\vspace{1em} 
\noindent
Auf dieser Basis gelangt die vorliegende Arbeit zu dem Schluss, dass die Kombination aus API-Architektur und Datenbanktechnologie genau auf die spezifischen Anforderungen eines Anwendungsfalls abgestimmt werden muss. Während REST und relationale Datenbanken eine bewährte Lösung für klassische Anwendungen darstellen, bieten GraphQL und Graphdatenbanken eine leistungsfähige Alternative, die zudem stark vernetzte Anfragen performanter bearbeiten kann.

% chapter fazit (end)



